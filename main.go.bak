package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os/exec"
	"strconv"
)

type LimitRequest struct {
	Dev  string `json:"dev"`
	Port int    `json:"port"`
	Up   string `json:"up"`
	Down string `json:"down"`
}

type APIResponse struct {
	Success bool   `json:"success"`
	Message string `json:"message"`
	Port    int    `json:"port,omitempty"`
	Rate    string `json:"rate,omitempty"`
}

func run(args ...string) error {
	cmd := exec.Command("tc", args...)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return &execError{err: err, output: string(out)}
	}
	return nil
}

type execError struct {
	err    error
	output string
}

func (e *execError) Error() string {
	return e.err.Error() + ": " + e.output
}

// 确保 root qdisc 存在
func ensureBase(dev string) {
	_ = run("qdisc", "del", "dev", dev, "root")
	_ = run("qdisc", "add", "dev", dev, "root", "handle", "1:", "htb", "default", "999")
	_ = run("class", "add", "dev", dev, "parent", "1:", "classid", "1:999",
		"htb", "rate", "10gbit", "ceil", "10gbit")
}

// /limit 接口
func limitHandler(w http.ResponseWriter, r *http.Request) {
	var req LimitRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeJSON(w, APIResponse{Success: false, Message: "invalid JSON: " + err.Error()})
		return
	}

	classid := "1:" + strconv.Itoa(req.Port)

	// 修改或新建 class
	if err := run("class", "change", "dev", req.Dev, "classid", classid,
		"htb", "rate", req.Up, "ceil", req.Up); err != nil {
		// 如果不存在，尝试 replace
		if err2 := run("class", "replace", "dev", req.Dev, "parent", "1:",
			"classid", classid, "htb", "rate", req.Up, "ceil", req.Up); err2 != nil {
			writeJSON(w, APIResponse{Success: false, Message: err2.Error()})
			return
		}
	}

	// 添加双向 filter
	_ = run("filter", "replace", "dev", req.Dev, "parent", "1:",
		"protocol", "ip", "prio", "1", "u32",
		"match", "ip", "protocol", "6", "0xff",
		"match", "ip", "dport", strconv.Itoa(req.Port), "0xffff",
		"flowid", classid)

	_ = run("filter", "replace", "dev", req.Dev, "parent", "1:",
		"protocol", "ip", "prio", "1", "u32",
		"match", "ip", "protocol", "6", "0xff",
		"match", "ip", "sport", strconv.Itoa(req.Port), "0xffff",
		"flowid", classid)

	writeJSON(w, APIResponse{Success: true, Message: "Limit applied", Port: req.Port, Rate: req.Up})
}

// /unlimit 接口
func unlimitHandler(w http.ResponseWriter, r *http.Request) {
	var req LimitRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		writeJSON(w, APIResponse{Success: false, Message: "invalid JSON: " + err.Error()})
		return
	}

	classid := "1:" + strconv.Itoa(req.Port)
	p := strconv.Itoa(req.Port)

	_ = run("class", "del", "dev", req.Dev, "classid", classid)
	_ = run("filter", "del", "dev", req.Dev, "parent", "1:", "protocol", "ip", "prio", "1", "u32",
		"match", "ip", "protocol", "6", "0xff", "match", "ip", "dport", p, "0xffff")
	_ = run("filter", "del", "dev", req.Dev, "parent", "1:", "protocol", "ip", "prio", "1", "u32",
		"match", "ip", "protocol", "6", "0xff", "match", "ip", "sport", p, "0xffff")

	writeJSON(w, APIResponse{Success: true, Message: "Limit removed", Port: req.Port})
}

func writeJSON(w http.ResponseWriter, resp APIResponse) {
	w.Header().Set("Content-Type", "application/json")
	if !resp.Success {
		w.WriteHeader(http.StatusBadRequest)
	}
	_ = json.NewEncoder(w).Encode(resp)
}

func main() {
	dev := "eth0"
	ensureBase(dev)

	http.HandleFunc("/limit", limitHandler)
	http.HandleFunc("/unlimit", unlimitHandler)

	log.Println("API listening on :8088")
	log.Fatal(http.ListenAndServe(":8088", nil))
}
